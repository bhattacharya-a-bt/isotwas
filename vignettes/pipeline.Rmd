---
title: "Train an isoTWAS model"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Train an isoTWAS model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

This module will cover how to use functions from `isotwas` to train an multivariate `isotwas` model for isoform-level expression. Along the way, we'll be covering some practical considerations for computation and feature selection.

```{r setup, echo=F, message=F}
library(isotwas)
```

## Train predictive model

To train a multivariate model, we need:

1.  a matrix of dosages of SNPs, and

2.  a matrix of isoform-level expressions for a given gene.

Isoform expression estimated from pseudo-alignment methods like [`salmon`](https://combine-lab.github.io/salmon/) and [`kallisto`](https://pachterlab.github.io/kallisto/) provide bootstrapped estimates expression across a number of iterations. This information can be included into model training, as illustrated below.

[**Practical consideration**]{.underline}: Ideally, to reduce your memory usage, we recommend storing your genetic data as `PLINK` format data (ideally as `.bed`/`bim`/`fam` or `.pgen`/`.pvar`/`.psam`). For a given gene, use `PLINK` to [select only SNPs](https://www.cog-genomics.org/plink/2.0/filter) on the same chromosome and within 1 Megabase of the gene body. Then, you can use the [`bigsnpr` package](https://privefl.github.io/bigsnpr/) read in this "condensed" file set. Make sure your isoform expression matrix is log-transformed and residualized by covariates that are normally used in a QTL analysis (i.e., age, sex, principal components of the genotype matrix, [PEER factors](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3398141/) or [hidden covariates with prior](https://pubmed.ncbi.nlm.nih.gov/23874524/) for the full expression matrix). In order to ensure maximal overlap between the model and the GWAS we will eventually use for trait mapping, we suggest restricting the SNPs in the QTL panel to only those present in the LD reference panel or to those annotated by the [HapMap3 Project](https://www.nature.com/articles/nature02168). This will ensure proper standard error calculations.

For this vignette about training an model, we'll use some toy genetic and transcriptomic data provided.

```{r generate_genetic_data}
train_bed = system.file("extdata", "train.bed", package = "isotwas")
snps = bigsnpr::snp_attach(bigsnpr::snp_readBed2(train_bed,
                                                 backingfile = tempfile()))
dim(snps$genotypes[])

isoform_mat = readRDS(system.file("extdata", "isoform_exp.RDS", package = "isotwas"))
dim(isoform_mat)
```

This reads in a SNP matrix with dimensions $300 \times 4542$, with samples along the rows and SNPs along the columns and a isoform-level expression matrix of dimension $300 \times 3$, with isoforms along the columns.

[**Practical consideration**]{.underline}: Though this is not a requirement for the isotwas pipeline, we recommend a feature selection step based on cis-heritability of isoform-level expression. Prior of model training for isoforms of a given gene, we recommend that users compute the heritability of all expressed isoforms of a gene using [`GCTA`](https://yanglab.westlake.edu.cn/software/gcta/#Overview) (ideally the [`gcta-nr-robust` executable in `FUSION`](http://gusevlab.org/projects/fusion/)). We recommend users only train models for isoforms that have positive heritability at nominal $P < 0.05$ or $0.01$.

[**Practical consideration**]{.underline}: Prior to heritability analysis and model training, it is imperative that your expression data is residualized by relevant covariates (i.e. principal components of genotype matrix, hidden covariates or PEER factors of the expression matrix, clinical/demographic covariates). A general rule of thumb is if you would include the covariate in an eQTL/isoform-level eQTL analysis, you should include it in the residualization process.

Let's jitter our expression matrix a little to generate 10 bootstrapped estimates of the matrix. Keep in mind that these replicates, theoretically, should not affect the effect size estimates but will help in seeding the estimation process of the correlation between isoforms/error in the multivariate model.

```{r bootstrap}
boot_list = lapply(1:10,function(i){jitter(isoform_mat)})
isoform_mat_rep = rlist::list.rbind(boot_list)
rownames(isoform_mat_rep) = rep(paste0('Sample',1:nrow(snps$fam)),10)
colnames(isoform_mat_rep) = paste0('Isoform',1:ncol(isoform_mat_rep))
dim(isoform_mat_rep)
```

## Available Prediction Methods

The `compute_isotwas()` function supports 9 multivariate prediction methods:

| Method | Description |
|--------|-------------|
| `mrce_lasso` | Multivariate Regression with Covariance Estimation (MRCE) - jointly estimates regression coefficients and error covariance |
| `multi_enet` | Multivariate elastic net - fits elastic net for each isoform with shared penalty |
| `joinet` | Joinet stacked elastic net - uses cross-predictions to improve multivariate prediction |
| `spls` | Sparse partial least squares - finds latent components that predict all isoforms |
| `sgl` | Sparse group lasso - encourages both within-group and across-group sparsity |
| `mtlasso` | Multi-task lasso (L21) - joint feature selection across all isoforms |
| `stacking` | Super learner stacking - combines predictions from multiple base methods |
| `graph_reg` | Graph-regularized regression - incorporates isoform similarity structure |
| `univariate` | Best of univariate methods (elastic net, BLUP, SuSiE) per isoform |

## Training a Model

Now, we can train the model using the `compute_isotwas()` function. Make sure the SNP matrix has clear labels for the SNP identifiers that are relevant to your study.

The function now provides detailed progress output by default (`verbose = TRUE`), showing:

- Data summary (samples, SNPs, transcripts)
- Method-by-method progress with timing
- Per-method R² performance
- Final results comparison table

```{r train, message = F, warning=FALSE, eval=F}
snp_mat = as.matrix(snps$genotypes[])
colnames(snp_mat) = snps$map$marker.ID
rownames(snp_mat) = snps$fam$sample.ID

# Train with all methods (recommended for best model selection)
isotwas_model = compute_isotwas(
  X = snp_mat,
  Y = isoform_mat,
  Y.rep = isoform_mat_rep,
  R = 10,
  id = rownames(isoform_mat_rep),
  omega_est = 'replicates',
  omega_nlambda = 5,
  nfolds = 5,
  verbose = TRUE,
  seed = 1789,
  run_all = TRUE,        # Run all 9 methods
  return_all = TRUE      # Return results from all methods
)
```

### Running Specific Methods

If you want to run only specific methods (e.g., for faster computation), set `run_all = FALSE` and specify the methods:

```{r train_specific, message = F, warning=FALSE, eval=F}
# Run only a subset of methods
isotwas_model = compute_isotwas(
  X = snp_mat,
  Y = isoform_mat,
  Y.rep = isoform_mat_rep,
  R = 10,
  id = rownames(isoform_mat_rep),
  method = c('mrce_lasso', 'multi_enet', 'sgl', 'univariate'),
  nfolds = 5,
  verbose = TRUE,
  seed = 1789,
  run_all = FALSE
)
```

### Using Graph-Regularized Regression

The `graph_reg` method can incorporate prior knowledge about isoform similarity (e.g., shared exon structure). You can create a similarity matrix from a GTF annotation file:

```{r graph_reg, eval=F}
# Create similarity matrix from GTF (based on shared exons)
sim_result = similarity_from_gtf(
  gtf_path = "gencode.v45.annotation.gtf.gz",
  gene = "BRCA1",
  method = "jaccard"  # Options: "jaccard", "overlap_coef", "binary"
)

# Use in model training
isotwas_model = compute_isotwas(
  X = snp_mat,
  Y = isoform_mat,
  Y.rep = isoform_mat_rep,
  R = 10,
  id = rownames(isoform_mat_rep),
  similarity_matrix = sim_result$similarity_matrix,
  method = c('multi_enet', 'graph_reg', 'univariate'),
  run_all = FALSE,
  verbose = TRUE,
  seed = 1789
)
```

## Function Parameters

A few notes on the key options:

-   **`omega_est`**: By selecting `omega_est = 'replicates'`, we use the bootstrapped replicates to estimate the correlation between isoforms. The alternative is `omega_est = 'mean'`, which will use whatever matrix you submit for `Y`.

-   **`omega_nlambda`**: Number of steps between fully dense to fully sparse in the correlation matrix estimation. We recommend 5-10 as the default.

-   **`method`**: Vector of methods to use. By default with `run_all = TRUE`, all 9 methods are run and the best model is selected.

-   **`similarity_matrix`**: Optional matrix for `graph_reg` method. Can be created using `similarity_from_gtf()` or `create_similarity_from_exons()`.

-   **`predict_nlambda`**: Number of penalty variables for `mrce_lasso`. We recommend 10-20.

-   **`alpha`**: Elastic net mixing parameter (0 = ridge, 1 = lasso, 0.5 = elastic net).

-   **`verbose`**: If `TRUE` (default), prints detailed progress including per-method timing and performance.

-   **`run_all`**: If `TRUE`, all methods will be run regardless of `method` parameter.

-   **`return_all`**: If `TRUE`, results from all methods are returned (useful for method comparison).

## Examining Results

The output from `compute_isotwas()` is an `isotwas_result` object with several components:

```{r examine, eval=F}
# Print summary
print(isotwas_model)

# Access the comparison table (R² for each method)
isotwas_model$comparison

# Access the best model
isotwas_model$best_models

# Access individual transcript results
isotwas_model$best_models$Isoform1$r2
isotwas_model$best_models$Isoform1$weights

# Get the full weight matrix
weight_mat = get_weight_matrix(isotwas_model$best_models)
```

## Converting the Model

We can convert the model from a list to a tibble or data.frame using `convert_model()`:

Let's take a look at what a sample model looks like:

```{r sample}
model_isotwas = readRDS(system.file("extdata", "model_example.RDS", package = "isotwas"))
class(model_isotwas)
length(model_isotwas)
names(model_isotwas)
model_isotwas$Model[[1]]
```

This model object is a list with a `Model` and a `R2` slot. The `Model` slot stores a list of models for each isoform.

We can convert this model from a list to a `tibble` using the `convert_model()` function. Make sure you have an annotation object to have position and REF/ALT allele information.

```{r convert}
model_tsv = convert_model(model_isotwas,
                          snp_annot = snps$map,
                          snp_var = 'marker.ID')
model_tsv
```

## Method Recommendations

Based on simulations and real data analyses:

1. **Default recommendation**: Use `run_all = TRUE` to evaluate all methods and let the function select the best model based on cross-validated R².

2. **For speed**: If computation time is a concern, start with `c('multi_enet', 'sgl', 'univariate')` which provides a good balance of multivariate and univariate approaches.

3. **When isoforms share structure**: Use `graph_reg` with a similarity matrix derived from shared exons. This helps when isoforms have correlated genetic effects due to shared regulatory regions.

4. **For robust predictions**: The `stacking` method combines multiple base methods and often provides stable predictions, especially when different methods perform well for different isoforms.

5. **For joint feature selection**: Use `mtlasso` or `sgl` when you expect SNPs to affect multiple isoforms simultaneously.
