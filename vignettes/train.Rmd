---
title: "Train an isotwas model"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Train an isotwas model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This module will cover how to use functions from `isotwas` to train an multivariate isotwas model for isoform-level expression. Along the way, we'll be covering some practical considerations for computation and feature selection.

```{r setup, echo=F, message=F}
library(isotwas)
```

To train a multivariate model, we need:

1.  a matrix of dosages of SNPs, and

2.  a matrix of isoform-level expressions for a given gene.

Isoform expression estimated from pseudo-alignment methods like [`salmon`](https://combine-lab.github.io/salmon/) and [`kallisto`](https://pachterlab.github.io/kallisto/) provide bootstrapped estimates expression across a number of iterations. This information can be included into model training, as illustrated below.

[**Practical consideration**]{.ul}: Ideally, to reduce your memory usage, we recommend storing your genetic data as `PLINK` format data (ideally as `.bed`/`bim`/`fam` or `.pgen`/`.pvar`/`.psam`). For a given gene, use `PLINK` to [select only SNPs](https://www.cog-genomics.org/plink/2.0/filter) on the same chromosome and within 1 Megabase of the gene body. Then, you can use the [`bigsnpr` package](https://privefl.github.io/bigsnpr/) read in this "condensed" file set.

For this vignette, we'll generate some toy genetic and transcriptomic data with $p = 3$ isoforms for a gene and $k = 500$ SNPs within 1 Megabase of the gene across $n = 200$ samples.

```{r generate_genetic_data}
p = 3; k = 500; n = 200

set.seed(1789) 
maf = runif(k,0.05,0.5) 
gen_mat = sapply(maf,function(freq){
  return(rbinom(n,2,freq))
}) 
rownames(gen_mat) = paste0('Sample',1:n) 
colnames(gen_mat) = paste0('SNP',1:k) 
dim(gen_mat)
```

This generates a $200 \times 500$ SNP matrix saved to gen_mat. These SNPs are coded as 0, 1, and 2, where the $ij$-th element of gen_mat represents the number of alternative alleles at SNP $j$ for sample $i$.

Now, let's make our matrix of isoform expression (call it `isoform_mat`) that is the product of the SNP matrix gen_mat and a sparse isoform effect matrix (`b_isoqtl`).

```{r generate_exp_data}
set.seed(1789) 
isoform_mat = matrix(nrow = n, ncol = k) 
effects = rnorm(k*p, mean = 0, sd = 0.05) 
effects[rbinom(k*p,1,0.01) != 1] = 0 
b_isoqtl = matrix(effects, nrow = k)

isoform_mat = gen_mat %*% b_isoqtl 
rownames(isoform_mat) = paste0('Sample',1:n) 
colnames(isoform_mat) = paste0('Isoform',1:p) 
dim(isoform_mat)
```

[**Practical consideration**]{.ul}: Though this is not a requirement for the isotwas pipeline, we recommend a feature selection step based on cis-heritability of isoform-level expression. Prior of model training for isoforms of a given gene, we recommend that users compute the heritability of all expressed isoforms of a gene using [`GCTA`](https://yanglab.westlake.edu.cn/software/gcta/#Overview) (ideally the [`gcta-nr-robust` executable in `FUSION`](http://gusevlab.org/projects/fusion/)). We recommend users only train models for isoforms that have positive heritability at nominal $P < 0.05$ or $0.01$.

[**Practical consideration**]{.ul}: Prior to heritability analysis and model training, it is imperative that your expression data is residualized by relevant covariates (i.e. principal components of genotype matrix, hidden covariates or PEER factors of the expression matrix, clinical/demographic covariates). A general rule of thumb is if you would include the covariate in an eQTL/isoform-level eQTL analysis, you should include it in the residualization process.

Let's jitter our expression matrix a little to generate 10 bootstrapped estimates of the matrix. Keep in mind that these replicates, theoretically, should not affect the effect size estimates but will help in seeding the estimation process of the correlation between isoforms/error in the multivariate model.

```{r bootstrap}
boot_list = lapply(1:10,function(i){jitter(isoform_mat)}) 
isoform_mat_rep = rlist::list.rbind(boot_list) 
rownames(isoform_mat_rep) = rep(paste0('Sample',1:n),10) 
colnames(isoform_mat_rep) = paste0('Isoform',1:p) 
dim(isoform_mat_rep)
```

Now, we can train the model using the `compute_isotwas()` function:

```{r train, message = F, warning=FALSE, eval=F}
isotwas_model = isotwas::compute_isotwas(X = gen_mat, 
                                         Y = isoform_mat, 
                                         Y.rep = isoform_mat_rep,
                                         R = 10, 
                                         id = rownames(isoform_mat_rep), 
                                         omega_est = 'replicates', 
                                         omega_nlambda = 5, 
                                         method = c('mrce_lasso', 
                                                    'multi_enet', 
                                                    'univariate',
                                                    'mvsusie'),
                                         predict_nlambda = 10, 
                                         family = 'gaussian', 
                                         scale = FALSE, 
                                         alpha = 0.5, 
                                         nfolds = 5, 
                                         verbose = FALSE, 
                                         tx_names = paste0('Isoform',1:3), 
                                         seed = 1789, 
                                         run_all = FALSE, 
                                         return_all = TRUE)
```

A few notes on the options in the function:

-   By selecting `omega_est = 'replicates'` , we are used the bootstrapped replicates to estimate the correlation between isoforms to seed any methods that require this matrix. The alternative is `omega_est = 'mean'` , which will use whatever matrix you submit for `Y`.

-   `omega_nlambda` selects the number of steps between fully dense to fully sparse in the correlation matrix estimation. We recommend 5-10 as the default here.

-   There are 6 total methods to predict expression. However, through simulations and real data examples, we recommend the four shown here as the default in the `method` option.

-   `predict_nlambda` is the number of penalty variables that are considered from the `mrce_lasso` method. We recommend 10-20 for this variable.

-   `family` and `alpha` are for `multi_enet` and `univariate` to determine how elastic net regression is run. The default is that the response follows a Normal distribution and the mixing parameter is set to 0.5.

-   If `run_all = TRUE`, then all 6 methods will be run.

-   If `return_all = TRUE`, then predicted values for each isoform and predictive performance for all methods and all isoforms will be outputted.

We can convert the model from a list (the output from `compute_isotwas()`) to a tibble or data.frame using `convert_model(isotwas_model)`.
